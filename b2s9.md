# Taller Individual  3
## Reactive Stream

**Semana**: 9

**Objetivos**:

- Aplicar los conocimientos sobre Reactive Stream.
- Generar y procesar flujos de datos reactivos.



### Descripci√≥n:

Resuelva los siguientes problemas.

### Problema 1
**Sincronizaci√≥n de Sensores**

Descripci√≥n: Simula dos sensores que emiten valores peri√≥dicos:

- Sensor1: Rango [20¬∞C, 30¬∞C], cada 1 segundo.
- Sensor2: Rango [30¬∞C, 40¬∞C], cada 1.5 segundos.
- Usa zip para combinar los valores de ambos sensores en un solo flujo.
- Det√©n el flujo despu√©s de 10 pares de valores.
- Genera una alerta si la diferencia absoluta entre las lecturas de Sensor1 y Sensor2 es mayor a 5¬∞C.
  

```mathematica
Sensor1: 22¬∞C, Sensor2: 27¬∞C, Difference: 5¬∞C
Sensor1: 24¬∞C, Sensor2: 34¬∞C, Difference: 10¬∞C
üö® ALERT! Significant difference detected: 10¬∞C
```
```Scala
package bim2_semana9
import rx.lang.scala.Observable
import scala.util.Random
import scala.concurrent.duration._

object Problema1 extends App {

  // Sensor 1: valores entre 20 y 30, cada 1 segundo
  //Se emite un valor nuevo cada 1 segundo
  val sensor1 = Observable.interval(1.second)
    .map(_ => Random.between(20, 30))

  // Sensor 2: valores entre 30 y 40, cada 1.5 segundos
  //Se emite un valor nuevo cada 1.5 segundo
  val sensor2 = Observable.interval(1.5.second)
    .map(_ => Random.between(30, 40))

  // Combinar los sensores con zip y tomar 10 pares
  sensor1.zip(sensor2) // Une los valores emitidos de cada sensor en pares (val1, val2)
    .take(10) //Toma los 10 valores
    .subscribe( // Se suscribe al flujo para procesar los datos
//Cada vez que llega un par de valores se calcula la diferencia entre ambos sensores
      onNext = {
        case (val1, val2) =>
          val diff = (val1 - val2).abs
          //Muestra la diferencia
          println(s"Sensor1: $val1¬∞C, Sensor2: $val2¬∞C, Difference: $diff¬∞C")
          // Si la diferencia es mayor a 5¬∞C, genera una alerta
          if (diff > 5)
            println(s"üö® ALERT! Significant difference detected: $diff¬∞C")
      },
      //Para los errrores si sucede se muestra ahi
      onError = e => println(s"Error: ${e.getMessage}"),
      //Sale cuando termina los 10 pares
      onCompleted = () => println("Stream completed!")
    )

  // Mantener viva la aplicaci√≥n el tiempo suficiente
  Thread.sleep(20000)
}

```
Se crea el sensor 1, que genera un valor aleatorio entre 20 y 30 grados.
Este sensor emite un nuevo valor cada 1 segundo.

Se crea el sensor 2, que genera un valor aleatorio entre 30 y 40 grados.
Este sensor emite un nuevo valor cada 1.5 segundos.

Ambos sensores se combinan usando zip, que toma el valor m√°s reciente de cada sensor y los empareja como (valor1, valor2).
Luego se usa subscribe para procesar esos datos cuando llegan:

En onNext, cada vez que llega un par de valores:

Se calcula la diferencia absoluta entre ambos sensores.

Se muestra en pantalla los valores emitidos y la diferencia.

Si la diferencia es mayor a 5 grados, se imprime una alerta.

En onError, se imprime cualquier error que ocurra.

### Problema 2
**Sistema de Alerta Complejo**

Descripci√≥n: Simula tres sensores que emiten datos peri√≥dicos:

- Sensor1: Temperatura (20¬∞C a 30¬∞C).
- Sensor2: Humedad (40% a 60%).
- Sensor3: Presi√≥n (950 hPa a 1050 hPa).
- Combina los datos de los tres sensores y detecta si alguna de las m√©tricas est√° fuera de rango.
- Det√©n el flujo despu√©s de 20 combinaciones.

```yaml
Temperature: 22¬∞C, Humidity: 50%, Pressure: 970 hPa
Temperature: 25¬∞C, Humidity: 42%, Pressure: 1055 hPa
üö® ALERT! Pressure out of range: 1055 hPa
...
```
```scala
package bim2_semana9

import rx.lang.scala.Observable
import scala.util.Random
import scala.concurrent.duration._
object Problema2 extends App {


    // Sensor 1: Temperatura 20‚Äì30¬∞C, cada 1 segundo
  //sale cada 1 segundo
    val sensorTemp = Observable.interval(1.second)
      .map(_ => Random.between(20, 30))

    // Sensor 2: Humedad 40‚Äì60%, cada 1.2 segundos
    //sale cada 1.2 segundos
    val sensorHumed = Observable.interval(1.2.second)
      .map(_ => Random.between(40, 60))

    // Sensor 3: Presi√≥n 950‚Äì1050 hPa, cada 1.5 segundos
    //sale cada 1.5 segundos
    val sensorPresi = Observable.interval(1.5.second)
      .map(_ => Random.between(950, 1050))

    // Combinar los tres sensores usando zip anidado
    val combinar = sensorTemp
      .zip(sensorHumed)
      // Une temperatura con humedad, creando pares (temp, hum)

      .zip(sensorPresi)// Une el par anterior con presi√≥n ‚Üí ((temp, hum), pres)
      .map { case ((t, h), p) => (t, h, p) }//Reordena los valores a una tupla de 3 elementos (t, h, p)
      .take(20)//toma solo 20 datos

    combinar.subscribe( // Se suscribe al stream para recibir los datos
      onNext = {// Cada vez que llega un nuevo dato: e imprimimos los valores
        case (temp, hum, pres) =>
          println(s"Temperature: $temp¬∞C, Humidity: $hum%, Pressure: $pres hPa")

          // Detectar alertas por fuera de rango
          if (temp < 20 || temp > 30)
            println(s"üö® ALERT! Temperature out of range: $temp¬∞C")

          if (hum < 40 || hum > 60)
            println(s"üö® ALERT! Humidity out of range: $hum%")

          if (pres < 950 || pres > 1050)
            println(s"üö® ALERT! Pressure out of range: $pres hPa")
      },
      //Para los errrores si sucede se muestra ahi
      onError = e => println(s"Error: ${e.getMessage}"),
      //Sale cuando termina los 20 pares
      onCompleted = () => println("Stream completed!")
    )

    // Mantener aplicaci√≥n viva
    Thread.sleep(30000)
  }

```
El codigo genera tres sensores que no existen f√≠sicamente, pero simulan c√≥mo funcionar√≠an:

-Sensor de temperatura: produce un n√∫mero entre 20 y 30 cada 1 segundo.

-Sensor de humedad: produce un n√∫mero entre 40 y 60 cada 1.2 segundos.

-Sensor de presi√≥n: produce un n√∫mero entre 950 y 1050 cada 1.5 segundos.

Todo esto lo haces usando Observable.interval, que permite emitir datos peri√≥dicamente como si fueran lecturas reales.
Luego se une los tres sensores usando zip
Cuando cada grupo de valores llega, el programa imprime la lectura completa

### Calificaci√≥n:

Para la calificaci√≥n, se debe presentar el trabajo realizado a su tutor. Es necesario recalcar que la presentaci√≥n se hace una √∫nica vez, no existe la posibilidad de presentaciones adicionales con correcciones.

- 10 puntos si presenta en el horario de pr√°cticas y experimentaci√≥n.
- 7 puntos presenta en el horario de tutor√≠a

La hora m√°xima de presentaci√≥n ser√° las 08h30
